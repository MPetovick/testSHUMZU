<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SafeMesh Plus - Red Mesh con WebRTC</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
    <style>
        :root {
            --primary: #2c3e50;
            --secondary: #3498db;
            --accent: #e74c3c;
            --light: #ecf0f1;
            --dark: #2c3e50;
            --success: #27ae60;
            --warning: #f39c12;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background-color: #f5f5f5;
            color: var(--dark);
            overflow: hidden;
        }
        
        header {
            background-color: var(--primary);
            color: white;
            padding: 1rem;
            text-align: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .container {
            display: flex;
            height: calc(100vh - 60px);
            max-width: 100%;
        }
        
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        
        #map {
            flex: 1;
            min-height: 300px;
            z-index: 1;
        }
        
        .controls {
            padding: 1rem;
            background: white;
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            align-items: center;
            box-shadow: 0 -2px 5px rgba(0,0,0,0.1);
        }
        
        .sidebar {
            width: 320px;
            background: white;
            border-left: 1px solid #ddd;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .sidebar-tabs {
            display: flex;
            border-bottom: 1px solid #ddd;
        }
        
        .sidebar-tab {
            flex: 1;
            padding: 0.8rem;
            text-align: center;
            cursor: pointer;
            background: #f8f9fa;
            transition: all 0.3s;
        }
        
        .sidebar-tab.active {
            background: white;
            font-weight: bold;
            border-bottom: 2px solid var(--secondary);
        }
        
        .sidebar-content {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
        }
        
        .tab-pane {
            display: none;
        }
        
        .tab-pane.active {
            display: block;
        }
        
        button {
            padding: 0.7rem 1.5rem;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        
        .btn-primary {
            background-color: var(--secondary);
            color: white;
        }
        
        .btn-emergency {
            background-color: var(--accent);
            color: white;
            animation: pulse 1.5s infinite;
        }
        
        .btn-success {
            background-color: var(--success);
            color: white;
        }
        
        .status {
            display: flex;
            align-items: center;
            margin-left: auto;
        }
        
        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }
        
        .connected {
            background-color: #2ecc71;
        }
        
        .disconnected {
            background-color: #e74c3c;
        }
        
        .user-list {
            list-style: none;
        }
        
        .user-item {
            display: flex;
            align-items: center;
            padding: 0.8rem;
            border-bottom: 1px solid #eee;
            cursor: pointer;
        }
        
        .user-item:hover {
            background-color: #f9f9f9;
        }
        
        .user-color {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            margin-right: 10px;
        }
        
        .user-name {
            flex: 1;
        }
        
        .user-distance {
            color: #777;
            font-size: 0.9rem;
        }
        
        .chat-messages {
            height: 300px;
            overflow-y: auto;
            border: 1px solid #eee;
            border-radius: 4px;
            padding: 0.8rem;
            margin-bottom: 1rem;
            background: #fafafa;
        }
        
        .message {
            margin-bottom: 0.8rem;
            padding: 0.5rem;
            border-radius: 4px;
            background: white;
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
        }
        
        .message-sender {
            font-weight: bold;
            color: var(--secondary);
        }
        
        .message-time {
            font-size: 0.7rem;
            color: #777;
            margin-left: 0.5rem;
        }
        
        .chat-input {
            display: flex;
            gap: 0.5rem;
        }
        
        .chat-input input {
            flex: 1;
            padding: 0.7rem;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        
        .note-form {
            display: flex;
            flex-direction: column;
            gap: 0.8rem;
            margin-bottom: 1rem;
        }
        
        .note-form input,
        .note-form textarea {
            padding: 0.7rem;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        
        .note-form textarea {
            min-height: 100px;
            resize: vertical;
        }
        
        .notes-list {
            list-style: none;
        }
        
        .note-item {
            padding: 0.8rem;
            border-bottom: 1px solid #eee;
            cursor: pointer;
        }
        
        .note-item:hover {
            background-color: #f9f9f9;
        }
        
        .note-title {
            font-weight: bold;
            margin-bottom: 0.3rem;
        }
        
        .note-content {
            font-size: 0.9rem;
            color: #555;
        }
        
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }
        
        .modal-content {
            background: white;
            padding: 1.5rem;
            border-radius: 8px;
            width: 90%;
            max-width: 500px;
            max-height: 80vh;
            overflow-y: auto;
        }
        
        .close-modal {
            float: right;
            font-size: 1.5rem;
            cursor: pointer;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }
        
        @keyframes vibrate {
            0% { transform: translate(0); }
            20% { transform: translate(-2px, 2px); }
            40% { transform: translate(-2px, -2px); }
            60% { transform: translate(2px, 2px); }
            80% { transform: translate(2px, -2px); }
            100% { transform: translate(0); }
        }
        
        .vibrate {
            animation: vibrate 0.5s linear infinite;
        }
        
        .notification {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 1rem;
            background: var(--primary);
            color: white;
            border-radius: 4px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            display: none;
            z-index: 1000;
        }
        
        @media (max-width: 768px) {
            .container {
                flex-direction: column;
            }
            
            .sidebar {
                width: 100%;
                height: 300px;
                border-left: none;
                border-top: 1px solid #ddd;
            }
            
            .controls {
                flex-direction: column;
                align-items: stretch;
            }
            
            .status {
                margin-left: 0;
            }
        }
    </style>
</head>
<body>
    <header>
        <h1>SafeMesh Plus</h1>
        <div class="status">
            <div id="statusIndicator" class="status-indicator disconnected"></div>
            <span id="statusText">Desconectado</span>
        </div>
    </header>
    
    <div class="container">
        <div class="main-content">
            <div id="map"></div>
            
            <div class="controls">
                <button id="toggleMesh" class="btn-primary">Activar Red Mesh</button>
                <button id="emergencyBtn" class="btn-emergency">Alerta de Emergencia</button>
                <button id="addNoteBtn" class="btn-success">Añadir Nota</button>
            </div>
        </div>
        
        <div class="sidebar">
            <div class="sidebar-tabs">
                <div class="sidebar-tab active" data-tab="users">Usuarios</div>
                <div class="sidebar-tab" data-tab="chat">Chat</div>
                <div class="sidebar-tab" data-tab="notes">Notas</div>
            </div>
            
            <div class="sidebar-content">
                <div class="tab-pane active" id="users-tab">
                    <h3>Usuarios Conectados</h3>
                    <ul id="usersList" class="user-list"></ul>
                </div>
                
                <div class="tab-pane" id="chat-tab">
                    <h3>Chat de Grupo</h3>
                    <div id="chatMessages" class="chat-messages"></div>
                    <div class="chat-input">
                        <input type="text" id="messageInput" placeholder="Escribe un mensaje...">
                        <button id="sendMessageBtn">Enviar</button>
                    </div>
                </div>
                
                <div class="tab-pane" id="notes-tab">
                    <h3>Notas de Ubicación</h3>
                    <ul id="notesList" class="notes-list"></ul>
                </div>
            </div>
        </div>
    </div>
    
    <div id="noteModal" class="modal">
        <div class="modal-content">
            <span class="close-modal">&times;</span>
            <h3>Añadir Nota de Ubicación</h3>
            <form id="noteForm" class="note-form">
                <input type="text" id="noteTitle" placeholder="Título de la nota" required>
                <textarea id="noteContent" placeholder="Contenido de la nota" required></textarea>
                <button type="submit" class="btn-primary">Guardar Nota</button>
            </form>
        </div>
    </div>
    
    <div id="notification" class="notification"></div>

    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
    <script>
        // Configuración y estado de la aplicación
        const config = {
            signalingServer: 'wss://signaling.example.com:443', // Servidor de señalización WebRTC
            maxPeers: 10,
            proximityAlertDistance: 100, // metros
            updateInterval: 5000 // ms
        };
        
        const state = {
            meshActive: false,
            peerConnections: new Map(),
            dataChannel: null,
            users: new Map(),
            notes: [],
            currentUser: null,
            signalingConnection: null,
            map: null,
            userMarker: null,
            watchId: null
        };
        
        // Colores para usuarios
        const userColors = [
            '#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6', 
            '#1abc9c', '#d35400', '#c0392b', '#16a085', '#8e44ad'
        ];
        
        // Inicialización cuando el DOM está listo
        document.addEventListener('DOMContentLoaded', function() {
            // Elementos de la UI
            const toggleMeshBtn = document.getElementById('toggleMesh');
            const emergencyBtn = document.getElementById('emergencyBtn');
            const addNoteBtn = document.getElementById('addNoteBtn');
            const statusIndicator = document.getElementById('statusIndicator');
            const statusText = document.getElementById('statusText');
            const usersList = document.getElementById('usersList');
            const chatMessages = document.getElementById('chatMessages');
            const messageInput = document.getElementById('messageInput');
            const sendMessageBtn = document.getElementById('sendMessageBtn');
            const notesList = document.getElementById('notesList');
            const noteModal = document.getElementById('noteModal');
            const noteForm = document.getElementById('noteForm');
            const closeModal = document.querySelector('.close-modal');
            const sidebarTabs = document.querySelectorAll('.sidebar-tab');
            const tabPanes = document.querySelectorAll('.tab-pane');
            const notification = document.getElementById('notification');
            
            // Generar ID de usuario único
            const userId = generateUserId();
            state.currentUser = {
                id: userId,
                name: `Usuario_${userId.substr(0, 5)}`,
                color: userColors[Math.floor(Math.random() * userColors.length)],
                lat: null,
                lng: null
            };
            
            // Inicializar mapa
            initMap();
            
            // Configurar event listeners
            toggleMeshBtn.addEventListener('click', toggleMeshNetwork);
            emergencyBtn.addEventListener('click', sendEmergencyAlert);
            addNoteBtn.addEventListener('click', showNoteModal);
            sendMessageBtn.addEventListener('click', sendChatMessage);
            messageInput.addEventListener('keypress', function(e) {
                if (e.key === 'Enter') sendChatMessage();
            });
            
            closeModal.addEventListener('click', function() {
                noteModal.style.display = 'none';
            });
            
            noteForm.addEventListener('submit', function(e) {
                e.preventDefault();
                saveNote();
            });
            
            sidebarTabs.forEach(tab => {
                tab.addEventListener('click', function() {
                    const tabName = this.getAttribute('data-tab');
                    
                    // Actualizar pestañas activas
                    sidebarTabs.forEach(t => t.classList.remove('active'));
                    tabPanes.forEach(p => p.classList.remove('active'));
                    
                    this.classList.add('active');
                    document.getElementById(`${tabName}-tab`).classList.add('active');
                });
            });
            
            // Cerrar modal al hacer clic fuera
            window.addEventListener('click', function(e) {
                if (e.target === noteModal) {
                    noteModal.style.display = 'none';
                }
            });
            
            // Funciones de inicialización
            function initMap() {
                state.map = L.map('map').setView([40.4168, -3.7038], 13); // Madrid por defecto
                
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '&copy; OpenStreetMap contributors'
                }).addTo(state.map);
                
                // Solicitar geolocalización
                if (navigator.geolocation) {
                    navigator.geolocation.getCurrentPosition(
                        position => {
                            const { latitude, longitude } = position.coords;
                            state.map.setView([latitude, longitude], 15);
                            
                            // Marcador del usuario actual
                            state.userMarker = L.marker([latitude, longitude])
                                .addTo(state.map)
                                .bindPopup('Tu ubicación')
                                .openPopup();
                                
                            state.currentUser.lat = latitude;
                            state.currentUser.lng = longitude;
                        },
                        error => {
                            console.error('Error obteniendo ubicación:', error);
                            alert('No se pudo obtener tu ubicación. Asegúrate de tener activado el GPS.');
                        }
                    );
                } else {
                    alert('Tu navegador no soporta geolocalización.');
                }
            }
            
            function toggleMeshNetwork() {
                if (state.meshActive) {
                    disconnectMesh();
                } else {
                    connectMesh();
                }
            }
            
            function connectMesh() {
                // Conectar al servidor de señalización
                state.signalingConnection = new WebSocket(config.signalingServer);
                
                state.signalingConnection.onopen = function() {
                    console.log('Conectado al servidor de señalización');
                    
                    // Registrar usuario
                    state.signalingConnection.send(JSON.stringify({
                        type: 'register',
                        userId: state.currentUser.id,
                        userData: state.currentUser
                    }));
                    
                    // Actualizar UI
                    statusIndicator.className = 'status-indicator connected';
                    statusText.textContent = 'Conectado';
                    toggleMeshBtn.textContent = 'Desactivar Red Mesh';
                    state.meshActive = true;
                    
                    // Iniciar seguimiento de ubicación
                    startLocationTracking();
                    
                    // Mostrar notificación
                    showNotification('Red Mesh activada. Conectando con usuarios cercanos...', 'success');
                };
                
                state.signalingConnection.onmessage = function(event) {
                    const message = JSON.parse(event.data);
                    
                    switch (message.type) {
                        case 'userList':
                            updateUserList(message.users);
                            break;
                        case 'offer':
                            handleOffer(message.offer, message.from);
                            break;
                        case 'answer':
                            handleAnswer(message.answer, message.from);
                            break;
                        case 'iceCandidate':
                            handleIceCandidate(message.candidate, message.from);
                            break;
                        case 'chatMessage':
                            displayChatMessage(message);
                            break;
                        case 'userLocation':
                            updateUserLocation(message.userId, message.lat, message.lng);
                            break;
                        case 'emergencyAlert':
                            handleEmergencyAlert(message);
                            break;
                    }
                };
                
                state.signalingConnection.onerror = function(error) {
                    console.error('Error en la conexión de señalización:', error);
                    showNotification('Error de conexión. Intentando reconectar...', 'error');
                    setTimeout(connectMesh, 3000);
                };
            }
            
            function disconnectMesh() {
                // Cerrar conexiones
                if (state.signalingConnection) {
                    state.signalingConnection.close();
                    state.signalingConnection = null;
                }
                
                state.peerConnections.forEach(peer => {
                    peer.close();
                });
                state.peerConnections.clear();
                
                // Detener seguimiento de ubicación
                stopLocationTracking();
                
                // Limpiar usuarios
                state.users.forEach(user => {
                    if (user.marker) state.map.removeLayer(user.marker);
                });
                state.users.clear();
                updateUsersListUI();
                
                // Actualizar UI
                statusIndicator.className = 'status-indicator disconnected';
                statusText.textContent = 'Desconectado';
                toggleMeshBtn.textContent = 'Activar Red Mesh';
                state.meshActive = false;
                
                showNotification('Red Mesh desactivada', 'info');
            }
            
            function startLocationTracking() {
                if (navigator.geolocation) {
                    state.watchId = navigator.geolocation.watchPosition(
                        position => {
                            const { latitude, longitude } = position.coords;
                            
                            // Actualizar marcador del usuario
                            if (state.userMarker) {
                                state.userMarker.setLatLng([latitude, longitude]);
                                state.map.panTo([latitude, longitude]);
                            }
                            
                            state.currentUser.lat = latitude;
                            state.currentUser.lng = longitude;
                            
                            // Enviar ubicación a través de la red mesh
                            broadcastLocation(latitude, longitude);
                            
                            // Comprobar proximidad con otros usuarios
                            checkProximity();
                        },
                        error => {
                            console.error('Error en seguimiento de ubicación:', error);
                        },
                        { 
                            enableHighAccuracy: true, 
                            timeout: 10000, 
                            maximumAge: 30000 
                        }
                    );
                }
            }
            
            function stopLocationTracking() {
                if (state.watchId && navigator.geolocation) {
                    navigator.geolocation.clearWatch(state.watchId);
                    state.watchId = null;
                }
            }
            
            function broadcastLocation(lat, lng) {
                if (!state.meshActive) return;
                
                // Enviar a través del servidor de señalización
                if (state.signalingConnection) {
                    state.signalingConnection.send(JSON.stringify({
                        type: 'userLocation',
                        userId: state.currentUser.id,
                        lat: lat,
                        lng: lng
                    }));
                }
                
                // También enviar a través de los canales de datos WebRTC
                state.peerConnections.forEach((peer, userId) => {
                    if (peer.dataChannel && peer.dataChannel.readyState === 'open') {
                        peer.dataChannel.send(JSON.stringify({
                            type: 'location',
                            lat: lat,
                            lng: lng
                        }));
                    }
                });
            }
            
            function checkProximity() {
                state.users.forEach(user => {
                    if (user.lat && user.lng && state.currentUser.lat && state.currentUser.lng) {
                        const distance = calculateDistance(
                            state.currentUser.lat, state.currentUser.lng,
                            user.lat, user.lng
                        );
                        
                        user.distance = distance;
                        
                        // Si está dentro del rango de alerta, activar vibración
                        if (distance <= config.proximityAlertDistance) {
                            triggerVibration();
                            showNotification(`${user.name} está a ${Math.round(distance)} metros`, 'proximity');
                        }
                    }
                });
                
                updateUsersListUI();
            }
            
            function calculateDistance(lat1, lon1, lat2, lon2) {
                // Fórmula de Haversine para calcular distancia entre dos puntos
                const R = 6371000; // Radio de la Tierra en metros
                const dLat = (lat2 - lat1) * Math.PI / 180;
                const dLon = (lon2 - lon1) * Math.PI / 180;
                const a = 
                    Math.sin(dLat/2) * Math.sin(dLat/2) +
                    Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * 
                    Math.sin(dLon/2) * Math.sin(dLon/2);
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
                return R * c;
            }
            
            function triggerVibration() {
                // Activar vibración si el dispositivo lo soporta
                if (navigator.vibrate) {
                    navigator.vibrate([200, 100, 200]);
                }
                
                // Efecto visual de vibración
                emergencyBtn.classList.add('vibrate');
                setTimeout(() => {
                    emergencyBtn.classList.remove('vibrate');
                }, 1000);
            }
            
            function sendEmergencyAlert() {
                if (!state.meshActive) {
                    showNotification('Activa la red mesh primero para enviar una alerta', 'error');
                    return;
                }
                
                const confirmation = confirm('¿Estás seguro de que quieres enviar una alerta de emergencia?');
                if (confirmation) {
                    // Enviar alerta a través del servidor de señalización
                    if (state.signalingConnection) {
                        state.signalingConnection.send(JSON.stringify({
                            type: 'emergencyAlert',
                            from: state.currentUser.id,
                            userName: state.currentUser.name,
                            lat: state.currentUser.lat,
                            lng: state.currentUser.lng,
                            timestamp: Date.now()
                        }));
                    }
                    
                    // También enviar a través de los canales de datos WebRTC
                    state.peerConnections.forEach((peer, userId) => {
                        if (peer.dataChannel && peer.dataChannel.readyState === 'open') {
                            peer.dataChannel.send(JSON.stringify({
                                type: 'emergency',
                                from: state.currentUser.id,
                                userName: state.currentUser.name,
                                lat: state.currentUser.lat,
                                lng: state.currentUser.lng
                            }));
                        }
                    });
                    
                    // Activar vibración
                    triggerVibration();
                    
                    showNotification('¡Alerta de emergencia enviada!', 'emergency');
                }
            }
            
            function handleEmergencyAlert(alert) {
                // Mostrar alerta emergente
                alert(`¡ALERTA DE EMERGENCIA de ${alert.userName}!`);
                
                // Centrar mapa en la ubicación de la emergencia
                if (alert.lat && alert.lng) {
                    state.map.setView([alert.lat, alert.lng], 16);
                    
                    // Añadir marcador especial para la emergencia
                    const emergencyMarker = L.marker([alert.lat, alert.lng], {
                        icon: L.divIcon({
                            className: 'emergency-marker',
                            html: '<div style="background-color: #e74c3c; width: 20px; height: 20px; border-radius: 50%; border: 3px solid white; box-shadow: 0 0 0 5px #e74c3c80;"></div>',
                            iconSize: [20, 20],
                            iconAnchor: [10, 10]
                        })
                    })
                    .addTo(state.map)
                    .bindPopup(`<strong>EMERGENCIA:</strong> ${alert.userName}`)
                    .openPopup();
                    
                    // Eliminar marcador después de 30 segundos
                    setTimeout(() => {
                        state.map.removeLayer(emergencyMarker);
                    }, 30000);
                }
                
                // Activar vibración
                triggerVibration();
            }
            
            function sendChatMessage() {
                const message = messageInput.value.trim();
                if (!message) return;
                
                // Crear objeto de mensaje
                const chatMessage = {
                    type: 'chatMessage',
                    from: state.currentUser.id,
                    userName: state.currentUser.name,
                    message: message,
                    timestamp: Date.now()
                };
                
                // Enviar a través del servidor de señalización
                if (state.signalingConnection) {
                    state.signalingConnection.send(JSON.stringify(chatMessage));
                }
                
                // También enviar a través de los canales de datos WebRTC
                state.peerConnections.forEach((peer, userId) => {
                    if (peer.dataChannel && peer.dataChannel.readyState === 'open') {
                        peer.dataChannel.send(JSON.stringify(chatMessage));
                    }
                });
                
                // Mostrar mensaje localmente
                displayChatMessage(chatMessage);
                
                // Limpiar campo de entrada
                messageInput.value = '';
            }
            
            function displayChatMessage(message) {
                const messageElement = document.createElement('div');
                messageElement.className = 'message';
                
                const time = new Date(message.timestamp).toLocaleTimeString();
                
                messageElement.innerHTML = `
                    <div>
                        <span class="message-sender">${message.userName}</span>
                        <span class="message-time">${time}</span>
                    </div>
                    <div>${message.message}</div>
                `;
                
                chatMessages.appendChild(messageElement);
                chatMessages.scrollTop = chatMessages.scrollHeight;
            }
            
            function showNoteModal() {
                if (!state.currentUser.lat || !state.currentUser.lng) {
                    showNotification('Esperando obtener tu ubicación...', 'error');
                    return;
                }
                
                noteModal.style.display = 'flex';
            }
            
            function saveNote() {
                const title = document.getElementById('noteTitle').value;
                const content = document.getElementById('noteContent').value;
                
                if (!title || !content) return;
                
                const note = {
                    id: generateId(),
                    title: title,
                    content: content,
                    lat: state.currentUser.lat,
                    lng: state.currentUser.lng,
                    userId: state.currentUser.id,
                    userName: state.currentUser.name,
                    timestamp: Date.now()
                };
                
                // Añadir nota al array
                state.notes.push(note);
                
                // Añadir marcador en el mapa
                addNoteMarker(note);
                
                // Actualizar lista de notas
                updateNotesList();
                
                // Cerrar modal y limpiar formulario
                noteModal.style.display = 'none';
                noteForm.reset();
                
                // Enviar nota a otros usuarios
                broadcastNote(note);
                
                showNotification('Nota guardada y compartida', 'success');
            }
            
            function addNoteMarker(note) {
                note.marker = L.marker([note.lat, note.lng], {
                    icon: L.divIcon({
                        className: 'note-marker',
                        html: '<div style="background-color: #f39c12; width: 16px; height: 16px; border-radius: 50%; border: 2px solid white; box-shadow: 0 0 0 3px #f39c1280;"></div>',
                        iconSize: [16, 16],
                        iconAnchor: [8, 8]
                    })
                })
                .addTo(state.map)
                .bindPopup(`
                    <strong>${note.title}</strong>
                    <p>${note.content}</p>
                    <small>Por: ${note.userName}</small>
                `);
            }
            
            function updateNotesList() {
                notesList.innerHTML = '';
                
                state.notes.forEach(note => {
                    const noteElement = document.createElement('li');
                    noteElement.className = 'note-item';
                    noteElement.innerHTML = `
                        <div class="note-title">${note.title}</div>
                        <div class="note-content">${note.content}</div>
                        <small>Por: ${note.userName}</small>
                    `;
                    
                    noteElement.addEventListener('click', () => {
                        state.map.setView([note.lat, note.lng], 16);
                        if (note.marker) note.marker.openPopup();
                    });
                    
                    notesList.appendChild(noteElement);
                });
            }
            
            function broadcastNote(note) {
                if (!state.meshActive) return;
                
                // Enviar a través del servidor de señalización
                if (state.signalingConnection) {
                    state.signalingConnection.send(JSON.stringify({
                        type: 'note',
                        note: note
                    }));
                }
                
                // También enviar a través de los canales de datos WebRTC
                state.peerConnections.forEach((peer, userId) => {
                    if (peer.dataChannel && peer.dataChannel.readyState === 'open') {
                        peer.dataChannel.send(JSON.stringify({
                            type: 'note',
                            note: note
                        }));
                    }
                });
            }
            
            function showNotification(message, type = 'info') {
                notification.textContent = message;
                notification.style.display = 'block';
                
                // Estilo según tipo
                notification.style.backgroundColor = 
                    type === 'error' ? '#e74c3c' :
                    type === 'success' ? '#27ae60' :
                    type === 'warning' ? '#f39c12' :
                    type === 'emergency' ? '#e74c3c' :
                    type === 'proximity' ? '#3498db' :
                    '#2c3e50';
                
                // Ocultar después de 3 segundos
                setTimeout(() => {
                    notification.style.display = 'none';
                }, 3000);
            }
            
            // Funciones auxiliares
            function generateUserId() {
                return Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
            }
            
            function generateId() {
                return Math.random().toString(36).substring(2, 9);
            }
            
            // Funciones WebRTC (simplificadas para el ejemplo)
            function handleOffer(offer, from) {
                // Implementar lógica de WebRTC para manejar ofertas
                console.log('Manejando oferta de:', from, offer);
            }
            
            function handleAnswer(answer, from) {
                // Implementar lógica de WebRTC para manejar respuestas
                console.log('Manejando respuesta de:', from, answer);
            }
            
            function handleIceCandidate(candidate, from) {
                // Implementar lógica de WebRTC para manejar candidatos ICE
                console.log('Manejando candidato ICE de:', from, candidate);
            }
            
            function updateUserList(users) {
                // Actualizar lista de usuarios
                console.log('Actualizando lista de usuarios:', users);
            }
            
            function updateUserLocation(userId, lat, lng) {
                // Actualizar ubicación de usuario
                console.log('Actualizando ubicación de usuario:', userId, lat, lng);
            }
            
            function updateUsersListUI() {
                usersList.innerHTML = '';
                
                state.users.forEach(user => {
                    const userElement = document.createElement('li');
                    userElement.className = 'user-item';
                    
                    const distanceText = user.distance ? `${Math.round(user.distance)}m` : 'Desconocida';
                    
                    userElement.innerHTML = `
                        <div class="user-color" style="background-color: ${user.color}"></div>
                        <div class="user-name">${user.name}</div>
                        <div class="user-distance">${distanceText}</div>
                    `;
                    
                    userElement.addEventListener('click', () => {
                        if (user.lat && user.lng) {
                            state.map.setView([user.lat, user.lng], 16);
                            if (user.marker) user.marker.openPopup();
                        }
                    });
                    
                    usersList.appendChild(userElement);
                });
            }
        });
    </script>
</body>
</html>
